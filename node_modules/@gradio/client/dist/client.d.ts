import type { ApiData, ApiInfo, ClientOptions, Config, DuplicateOptions, EndpointInfo, JsApiData, SpaceStatus, Status, SubmitReturn, UploadResponse } from "./types";
export declare class NodeBlob extends Blob {
    constructor(blobParts?: BlobPart[], options?: BlobPropertyBag);
}
export declare class Client {
    app_reference: string;
    options: ClientOptions;
    config: Config | undefined;
    api_info: ApiInfo<JsApiData> | undefined;
    api_map: Record<string, number>;
    session_hash: string;
    jwt: string | false;
    last_status: Record<string, Status["stage"]>;
    stream_status: {
        open: boolean;
    };
    pending_stream_messages: Record<string, any[][]>;
    pending_diff_streams: Record<string, any[][]>;
    event_callbacks: Record<string, () => Promise<void>>;
    unclosed_events: Set<string>;
    heartbeat_event: EventSource | null;
    fetch_implementation(input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
    eventSource_factory(url: URL): EventSource | null;
    view_api: () => Promise<ApiInfo<JsApiData>>;
    upload_files: (root_url: string, files: (Blob | File)[], upload_id?: string) => Promise<UploadResponse>;
    handle_blob: (endpoint: string, data: unknown[], endpoint_info: EndpointInfo<ApiData | JsApiData>) => Promise<unknown[]>;
    post_data: (url: string, body: unknown, additional_headers?: any) => Promise<unknown[]>;
    submit: (endpoint: string | number, data: unknown[], event_data?: unknown, trigger_id?: number | null) => SubmitReturn;
    predict: (endpoint: string | number, data?: unknown[], event_data?: unknown) => Promise<unknown>;
    open_stream: () => void;
    resolve_config: (endpoint: string) => Promise<Config | undefined>;
    constructor(app_reference: string, options?: ClientOptions);
    private init;
    static connect(app_reference: string, options?: ClientOptions): Promise<Client>;
    close(): void;
    static duplicate(app_reference: string, options?: DuplicateOptions): Promise<Client>;
    private _resolve_config;
    private config_success;
    handle_space_success(status: SpaceStatus): Promise<Config | void>;
    component_server(component_id: number, fn_name: string, data: unknown[] | {
        binary: boolean;
        data: Record<string, any>;
    }): Promise<unknown>;
    private prepare_return_obj;
}
/**
 * @deprecated This method will be removed in v1.0. Use `Client.connect()` instead.
 * Creates a client instance for interacting with Gradio apps.
 *
 * @param {string} app_reference - The reference or URL to a Gradio space or app.
 * @param {ClientOptions} options - Configuration options for the client.
 * @returns {Promise<Client>} A promise that resolves to a `Client` instance.
 */
export declare function client(app_reference: string, options?: ClientOptions): Promise<Client>;
export type ClientInstance = Client;
//# sourceMappingURL=client.d.ts.map